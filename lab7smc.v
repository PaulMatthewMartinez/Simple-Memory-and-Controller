
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module lab7smc(

	
 


	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	//output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output reg		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,
	

 // output reg[3:0] wr_addr,wr_addr_c,wr_data,wr_data_c,rd_data,rd_data_c,rd_addr,rd_addr_c,

input 		          		MAX10_CLK1_50,
output reg [25:0] divby,
output reg [25:0]divby_c,
output reg newgo

);

/*
if(reset==0)begin
		count_c=26'b00_0000_0000_0000_0000_0000_0000;
	end
	else begin
		if(count<divideby)begin
		count_c=count+26'b00_0000_0001_1000_0110_1010_0000;
		end
		else begin
		count_c=26'b00_0000_0000_0000_0000_0000_0000;
		end
	end

*/

always@(*)begin
	divby_c=divby;
	
	if(KEY[0]==1)begin
		if(divby[25:0]<26'b11_1111_1010_1111_0000_10000_0000)begin
			divby_c=divby_c+26'b00_0000_0000_0000_0000_0000_0001;
		/*
	if(divideby/26'b00_0000_0000_0000_0000_0000_1010)begin
	go=1;
	end
	else begin
	go=0;
	end
	*/
			newgo=0;
			LEDR[0]=1;
		end
		else begin
			divby_c=26'b00_0000_0000_0000_0000_0000_0000;
			newgo=1;
			
		end
	end
end

//=======================================================
//  REG/WIRE declarations
//=======================================================
reg [3:0]     mem[0:15];
reg [3:0] state_c,state;
wire gogo;
reg [3:0] wr_addr,wr_data,rd_data,rd_addr;
reg [3:0] wr_addr_c,wr_data_c,rd_data_c,rd_addr_c;
//reg [25:0] divby;
//reg [25:0]divby_c;
parameter TRAN_L0=4'b0000;
parameter TRAN_L1=4'b0001;
parameter TRAN_L2=4'b0010;
parameter TRAN_L3=4'b0011;
parameter TRAN_R0=4'b0100;
parameter TRAN_R1=4'b0101;
parameter TRAN_R2=4'b0110;
parameter TRAN_R3=4'b0111;
parameter TRAN_W0=4'b1000;
parameter TRAN_W1=4'b1001;
parameter TRAN_RR0=4'b1010;
parameter TRAN_RR1=4'b1011;
parameter TRAN_RR2=4'b1100;
parameter TRAN_RR3=4'b1101;
parameter WAIT=4'b1110;
//=======================================================
//  Structural coding
//=======================================================
/*
PulseGenerator PulseGenerator(
.clock(MAX10_CLK1_50),
.divideby(26'b00_0000_0000_0000_0000_0011_0010),
.go(gogo));
*/
 seg7 bcd2driver1(
.seggy(wr_addr),
.HEX0(HEX5));

 seg7 bcd2driver2(
.seggy(wr_data),
.HEX0(HEX4));

 seg7 bcd2driver3(
.seggy(rd_addr),
.HEX0(HEX3));

 seg7 bcd2driver4(
.seggy(rd_data),
.HEX0(HEX2));

 seg7 bcd2driver5(
.seggy(rd_data+1'b1),
.HEX0(HEX0));


reg n,rising_transition;
wire rising_transition_c;
//assign rising_transition_c = ~n & gogo;
//assign rising_transition_c = ~n & gogo;

always@(posedge MAX10_CLK1_50)begin
state <= #1 state_c;
wr_addr <= #1 wr_addr_c;
wr_data <= #1 wr_data_c;
rd_addr <= #1 rd_addr_c;
rd_data <= #1 rd_data_c;
divby <= #1 divby_c;
	
	mem[wr_addr] <= #1 wr_data;//write stuff
	rd_data <= #1 mem[rd_addr];//read stuff
	

/*
n <= #1 gogo;
rising_transition <= #1 rising_transition_c;
*/
end
/*
// declarations
reg n;
reg rising_transition;
wire rising_transition_c;
// logic to detect 0 in previous cycle and 1 in current cycle
assign rising_transition_c = ~n & KEY[1];
// flip-flop instantiations
always @(posedge MAX10_CLK1_50) begin
n <= #1 KEY[1];
rising_transition <= #1 rising_transition_c;


state <= #1 state_c;
wr_addr <= #1 wr_addr_c;
wr_data <= #1 wr_data_c;
rd_addr <= #1 rd_addr_c;
rd_data <= #1 rd_data_c;
end

*/
//26'b10_1111_1010_1111_0000_1000_0000//50million
always@(state)begin

state_c=state;

wr_data_c=wr_data;
wr_addr_c=wr_addr;
rd_addr_c=rd_addr;
rd_data_c=rd_data;

	case(state)
		TRAN_L0:begin
		wr_addr_c=4'b0000;
		wr_data_c=4'b0000;
		
			if(newgo == 1'b1)begin //on
			state_c=TRAN_L1;
			LEDR[8]=1'b0;

			

			
			end
		end
		TRAN_L1:begin
		wr_addr_c=4'b0001;
		wr_data_c=4'b0001;
		
			if(newgo == 1'b1)begin 
			state_c=TRAN_L2;
			LEDR[9]=0;
			
			end
		end
		TRAN_L2:begin
		wr_addr_c=4'b0010;
		wr_data_c=4'b0010;
		
			if(newgo == 1'b1)begin
			state_c=TRAN_L3;
			LEDR[9]=0;
		
			end
		end
		TRAN_L3:begin
		wr_addr_c=4'b0011;
		wr_data_c=4'b0011;

			if(newgo == 1'b1)begin
			state_c=TRAN_R0;
			LEDR[9]=0;
			
			end
		end
		TRAN_R0:begin
		rd_addr_c=4'b0011;
			if(newgo == 1'b1)begin
			state_c=TRAN_R1;
			LEDR[9]=1;
			
			end
		end
		TRAN_R1:begin

		rd_addr_c=4'b0010;
		
			if(newgo == 1'b1)begin
			state_c=TRAN_R2;
		
			
			LEDR[9]=1;
			end
		end
		TRAN_R2:begin
		
		rd_addr_c=4'b0001;
		
			if(newgo == 1'b1)begin
			state_c=TRAN_R3;
			
		
			LEDR[9]=1;
			end
		end
		TRAN_R3:begin

		rd_addr_c=4'b0000;
			if(newgo == 1'b1)begin
			state_c=TRAN_W0;
			
			LEDR[9]=1;
			end
		end
		TRAN_W0:begin
		wr_addr_c=4'b0000;
		wr_data_c=4'b0101;
		
			if(newgo == 1'b1)begin
			state_c=TRAN_W1;
			LEDR[9]=0;
			
			end
		end
		TRAN_W1:begin
		wr_addr_c=4'b0001;
		wr_data_c=4'b0110;
			if(newgo == 1'b1)begin
			state_c=TRAN_RR0;
			LEDR[9]=0;
			
			end
		end
		TRAN_RR0:begin //not working atm but got it to work

		rd_addr_c=4'b0011;
		rd_data_c=4'b0011;
			if(newgo == 1'b1)begin
			state_c=TRAN_RR1;
			LEDR[9]=0;
			
			end
		end
		TRAN_RR1:begin
		
		rd_addr_c=4'b0010;
		rd_data_c=4'b0010;
			if(newgo == 1'b1)begin
			state_c=TRAN_RR2;
			LEDR[9]=0;
			
			end
		end
		TRAN_RR2:begin
	
		rd_addr_c=4'b0001;
		rd_data_c=4'b0110;
			if(newgo == 1'b1)begin
			state_c=TRAN_RR3;
			LEDR[9]=0;
			
			end
		end
		TRAN_RR3:begin//working now
		
		rd_addr_c=4'b0000;
		rd_data_c=4'b0101;
			if(newgo == 1'b1)begin
			state_c=WAIT;
			LEDR[9]=0;
			
			end
		end
		WAIT:begin
		if(newgo == 1'b1)begin
			LEDR[8]=1'b1;
			state_c=TRAN_L0;
			end
		end
	endcase
	
	if (KEY[0] == 0)begin
	rd_addr_c=4'b0000;
	wr_addr_c=4'b0000;
		wr_data_c=4'b0000;
		rd_data_c=4'b0000;
				state_c=TRAN_L0;
	end
	
end
endmodule
